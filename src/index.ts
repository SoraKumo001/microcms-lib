import fetch from 'isomorphic-fetch';

interface MicroCMSResultType<T> {
  contents: T[];
  totalCount: number;
  offset: number;
  limit: number;
}
interface GetOptions<T> {
  draftKey?: string;
  fields?: ReadonlyArray<T>;
  depth?: number;
  globalKey?: boolean;
}
interface GetsOptions<T> {
  draftKey?: string;
  limit?: number;
  offset?: number;
  orders?: string;
  q?: string;
  fields?: T[];
  ids?: string;
  filters?: string;
  depth?: number;
  globalKey?: boolean;
}

const convertQuery = (
  query:
    | {
        [key: string]: string | ReadonlyArray<keyof unknown> | number | boolean | undefined;
      }
    | {}
) =>
  Object.entries(query).reduce(
    (a, [name, value], index) =>
      `${a}${index ? '&' : '?'}${name}=${Array.isArray(value) ? value.join(',') : value}`,
    ''
  );

/**
 * Class for MicroCMS API access
 *
 * @export
 * @class MicroCMS
 * @template T `EndPioints` generated by `microcms-typescript`.
 */
export class MicroCMS<
  T extends { [key in 'get' | 'post' | 'put' | 'patch']: P },
  P extends { [key in K]: T[keyof T][K] } = T[keyof T],
  K extends keyof T[keyof T] = keyof T[keyof T]
> {
  /**
   * Creates an instance of MicroCMS.
   * @param {} options
   * ```
   * {
   *   service: string; // `service`.microcms.io
   *   apiKey?: string; // API-KEY to read
   *   apiWriteKey?: // string; API-KEY to writing
   *   apiGlobalKey?: // string; API-KEY for reading drafts
   * }
   * ```
   * @memberof MicroCMS
   */
  constructor(
    private options: {
      service: string;
      apiKey?: string;
      apiWriteKey?: string;
      apiGlobalKey?: string;
    }
  ) {}

  /**
   * Get a single content
   *
   * @param {E} endpoint
   * @param {string} id
   * @param {GetOptions} options
   * ```
   * {
   *   draftKey?: string;
   *   fields?: ReadonlyArray<F>;
   *   depth?: number;
   *   globalKey?: boolean;
   * }
   * ```
   * @return {*}  content | null
   * @memberof MicroCMS
   */
  async get<E extends K, F extends keyof T['get'][E]>(
    endpoint: E,
    id: string,
    options: GetOptions<F> = {}
  ): Promise<Pick<T['get'][E], F> | null> {
    const { globalKey, ...o } = options;
    const queryString = options && convertQuery(o);
    const { service, apiKey, apiGlobalKey } = this.options;
    if (!apiKey) return null;
    return fetch(`https://${service}.microcms.io/api/v1/${endpoint}/${id}${queryString}`, {
      headers:
        globalKey && apiGlobalKey
          ? { 'X-API-KEY': apiKey, 'X-GLOBAL-DRAFT-KEY': apiGlobalKey }
          : { 'X-API-KEY': apiKey },
    })
      .then(async (res) => (res.status === 200 ? res.json() : null))
      .catch(() => null);
  }
  /**
   * Acquiring multiple contents
   *
   * @param {E} endpoint
   * @param {GetsOptions} options
   * ```
   * {
   *   draftKey?: string;
   *   limit?: number;
   *   offset?: number;
   *   orders?: string;
   *   q?: string;
   *   fields?: T[];
   *   ids?: string;
   *   filters?: string;
   *   depth?: number;
   *   globalKey?: boolean;
   * }
   * ```
   * @return {*}
   * ```
   * {
   *   contents: content[];
   *   totalCount: number;
   *   offset: number;
   *   limit: number;
   * } | null
   * ```
   * @memberof MicroCMS
   */
  async gets<E extends K, F extends keyof T['get'][E]>(
    endpoint: E,
    options: GetsOptions<F> = {}
  ): Promise<MicroCMSResultType<Pick<T['get'][E], F>> | null> {
    const { globalKey, ...o } = options;
    const queryString = options && convertQuery(o);
    const { service, apiKey, apiGlobalKey } = this.options;
    if (!apiKey) return null;
    return fetch(`https://${service}.microcms.io/api/v1/${endpoint}${queryString}`, {
      headers:
        globalKey && apiGlobalKey
          ? { 'X-API-KEY': apiKey, 'X-GLOBAL-DRAFT-KEY': apiGlobalKey }
          : { 'X-API-KEY': apiKey },
    })
      .then(async (res) => (res.status === 200 ? res.json() : null))
      .catch(() => null);
  }
  /**
   * Create new content
   *
   * @template E
   * @param {E} endpoint
   * @param {(Omit<T['post'][E], 'id' | 'createdAt' | 'updatedAt' | 'publishedAt' | 'revisedAt'> & {
   *       createdAt?: string;
   *       updatedAt?: string;
   *       publishedAt?: string;
   *       revisedAt?: string;
   *     })} params
   * @return {*}  {(Promise<string | null>)}
   * @memberof MicroCMS
   */
  async post<E extends K>(
    endpoint: E,
    params: Omit<T['post'][E], 'id' | 'createdAt' | 'updatedAt' | 'publishedAt' | 'revisedAt'> & {
      createdAt?: string;
      updatedAt?: string;
      publishedAt?: string;
      revisedAt?: string;
    }
  ): Promise<string | null> {
    const { service, apiWriteKey } = this.options;
    if (!apiWriteKey) return null;
    return fetch(`https://${service}.microcms.io/api/v1/${endpoint}`, {
      method: 'post',
      headers: { 'X-WRITE-API-KEY': apiWriteKey, 'Content-Type': 'application/json' },
      body: JSON.stringify(params),
    })
      .then(async (res) => (res.status === 201 ? (await res.json())['id'] : null))
      .catch(() => null) as ReturnType<typeof this.post>;
  }
  /**
   * Create a new content with ID
   *
   * @template E
   * @param {E} endpoint
   * @param {(string | undefined)} id
   * @param {T['put'][E]} params
   * @return {*}  {(Promise<string | null>)}
   * @memberof MicroCMS
   */
  async put<E extends K>(
    endpoint: E,
    id: string | undefined,
    params: T['put'][E]
  ): Promise<string | null> {
    const { service, apiWriteKey } = this.options;
    if (!apiWriteKey) return null;
    return fetch(`https://${service}.microcms.io/api/v1/${endpoint}/${id}`, {
      method: 'put',
      headers: { 'X-WRITE-API-KEY': apiWriteKey, 'Content-Type': 'application/json' },
      body: JSON.stringify(params),
    })
      .then(async (res) => (res.status === 201 ? (await res.json())['id'] : null))
      .catch(() => null) as ReturnType<typeof this.put>;
  }
  /**
   * Rewriting content
   *
   * @template E
   * @param {E} endpoint
   * @param {string} id
   * @param {T['patch'][E]} params
   * @return {*}  {(Promise<string | null>)}
   * @memberof MicroCMS
   */
  async patch<E extends K>(endpoint: E, id: string, params: T['patch'][E]): Promise<string | null> {
    const { service, apiWriteKey } = this.options;
    if (!apiWriteKey) return null;
    return fetch(`https://${service}.microcms.io/api/v1/${endpoint}/${id}`, {
      method: 'patch',
      headers: { 'X-WRITE-API-KEY': apiWriteKey, 'Content-Type': 'application/json' },
      body: JSON.stringify(params),
    })
      .then(async (res) => (res.status === 200 ? (await res.json())['id'] : null))
      .catch(() => null) as ReturnType<typeof this.patch>;
  }
  /**
   * Deleting content
   *
   * @template E
   * @param {E} endpoint
   * @param {string} id
   * @return {*}  {Promise<boolean>}
   * @memberof MicroCMS
   */
  async del<E extends K>(endpoint: E, id: string): Promise<boolean> {
    const { service, apiWriteKey } = this.options;
    if (!apiWriteKey) return false;
    return fetch(`https://${service}.microcms.io/api/v1/${endpoint}/${id}`, {
      method: 'delete',
      headers: { 'X-WRITE-API-KEY': apiWriteKey, 'Content-Type': 'application/json' },
    })
      .then(async (res) => (res.status === 202 ? true : false))
      .catch(() => false) as ReturnType<typeof this.del>;
  }

  /**
   *
   *
   * @template E
   * @template F
   * @param {E} endpoint
   * @param {string} id
   * @param {{
   *       draftKey?: string;
   *       fields?: ReadonlyArray<F>;
   *       depth?: number;
   *       globalKey?: boolean;
   *     }} [options={}]
   * @return {*}  {(Promise<
   *     | {
   *         code: 200;
   *         body: T['get'][E];
   *       }
   *     | { code: 401; body: { message: string } }
   *     | null
   *   >)}
   * @memberof MicroCMS
   */
  async get2<E extends K, F extends keyof P[E]>(
    endpoint: E,
    id: string,
    options: {
      draftKey?: string;
      fields?: ReadonlyArray<F>;
      depth?: number;
      globalKey?: boolean;
    } = {}
  ): Promise<
    | {
        code: 200;
        body: T['get'][E];
      }
    | { code: 401; body: { message: string } }
    | null
  > {
    const { globalKey, ...o } = options;
    const queryString = options && convertQuery(o);
    const { service, apiKey, apiGlobalKey } = this.options;
    if (!apiKey) return null;
    return fetch(`https://${service}.microcms.io/api/v1/${endpoint}/${id}${queryString}`, {
      headers:
        globalKey && apiGlobalKey
          ? { 'X-API-KEY': apiKey, 'X-GLOBAL-DRAFT-KEY': apiGlobalKey }
          : { 'X-API-KEY': apiKey },
    })
      .then(async (res) => ({ code: res.status, body: await res.json() }))
      .catch(() => null) as T['get'][K] | null;
  }
  /**
   *
   *
   * @template E
   * @template F
   * @param {E} endpoint
   * @param {{
   *       draftKey?: string;
   *       limit?: number;
   *       offset?: number;
   *       orders?: string;
   *       q?: string;
   *       fields?: ReadonlyArray<F>;
   *       ids?: string;
   *       filters?: string;
   *       depth?: number;
   *       globalKey?: boolean;
   *     }} [options={}]
   * @return {*}
   * @memberof MicroCMS
   */
  async gets2<E extends K, F extends keyof P[E]>(
    endpoint: E,
    options: {
      draftKey?: string;
      limit?: number;
      offset?: number;
      orders?: string;
      q?: string;
      fields?: ReadonlyArray<F>;
      ids?: string;
      filters?: string;
      depth?: number;
      globalKey?: boolean;
    } = {}
  ) {
    const { globalKey, ...o } = options;
    const queryString = options && convertQuery(o);
    const { service, apiKey, apiGlobalKey } = this.options;
    if (!apiKey) return null;
    return fetch(`https://${service}.microcms.io/api/v1/${endpoint}${queryString}`, {
      headers:
        globalKey && apiGlobalKey
          ? { 'X-API-KEY': apiKey, 'X-GLOBAL-DRAFT-KEY': apiGlobalKey }
          : { 'X-API-KEY': apiKey },
    })
      .then(async (res) => ({ code: res.status, body: await res.json() }))
      .catch(() => null) as Promise<
      | {
          code: 200;
          body: MicroCMSResultType<Pick<T['get'][E], F>>;
        }
      | { code: 401; body: { message: string } }
      | null
    >;
  }
  /**
   *
   *
   * @template E
   * @param {E} endpoint
   * @param {(Omit<T['post'][E], 'id' | 'createdAt' | 'updatedAt' | 'publishedAt' | 'revisedAt'> & {
   *       createdAt?: string;
   *       updatedAt?: string;
   *       publishedAt?: string;
   *       revisedAt?: string;
   *     })} params
   * @return {*}  {(Promise<
   *     { code: 400; body: { message: string } } | { code: 201; body: { id: string } } | null
   *   >)}
   * @memberof MicroCMS
   */
  async post2<E extends K>(
    endpoint: E,
    params: Omit<T['post'][E], 'id' | 'createdAt' | 'updatedAt' | 'publishedAt' | 'revisedAt'> & {
      createdAt?: string;
      updatedAt?: string;
      publishedAt?: string;
      revisedAt?: string;
    }
  ): Promise<
    { code: 400; body: { message: string } } | { code: 201; body: { id: string } } | null
  > {
    const { service, apiWriteKey } = this.options;
    if (!apiWriteKey) return null;
    return fetch(`https://${service}.microcms.io/api/v1/${endpoint}`, {
      method: 'post',
      headers: { 'X-WRITE-API-KEY': apiWriteKey, 'Content-Type': 'application/json' },
      body: JSON.stringify(params),
    })
      .then(async (res) => ({ code: res.status, body: await res.json() }))
      .catch(() => null) as ReturnType<typeof this.post2>;
  }
  /**
   *
   *
   * @template E
   * @param {E} endpoint
   * @param {(string | undefined)} id
   * @param {T['put'][E]} params
   * @return {*}  {(Promise<
   *     { code: 400; body: { message: string } } | { code: 201; body: { id: string } } | null
   *   >)}
   * @memberof MicroCMS
   */
  async put2<E extends K>(
    endpoint: E,
    id: string | undefined,
    params: T['put'][E]
  ): Promise<
    { code: 400; body: { message: string } } | { code: 201; body: { id: string } } | null
  > {
    const { service, apiWriteKey } = this.options;
    if (!apiWriteKey) return null;
    return fetch(`https://${service}.microcms.io/api/v1/${endpoint}/${id}`, {
      method: 'put',
      headers: { 'X-WRITE-API-KEY': apiWriteKey, 'Content-Type': 'application/json' },
      body: JSON.stringify(params),
    })
      .then(async (res) => ({ code: res.status, body: await res.json() }))
      .catch(() => null) as ReturnType<typeof this.put2>;
  }
  /**
   *
   *
   * @template E
   * @param {E} endpoint
   * @param {string} id
   * @param {T['patch'][E]} params
   * @return {*}  {(Promise<
   *     { code: 400; body: { message: string } } | { code: 200; body: { id: string } } | null
   *   >)}
   * @memberof MicroCMS
   */
  async patch2<E extends K>(
    endpoint: E,
    id: string,
    params: T['patch'][E]
  ): Promise<
    { code: 400; body: { message: string } } | { code: 200; body: { id: string } } | null
  > {
    const { service, apiWriteKey } = this.options;
    if (!apiWriteKey) return null;
    return fetch(`https://${service}.microcms.io/api/v1/${endpoint}/${id}`, {
      method: 'patch',
      headers: { 'X-WRITE-API-KEY': apiWriteKey, 'Content-Type': 'application/json' },
      body: JSON.stringify(params),
    })
      .then(async (res) => ({ code: res.status, body: await res.json() }))
      .catch(() => null) as ReturnType<typeof this.patch2>;
  }
  /**
   *
   *
   * @template E
   * @param {E} endpoint
   * @param {string} id
   * @return {*}  {(Promise<
   *     { code: 400; body: { message: string } } | { code: 202; body: { id: string } } | null
   *   >)}
   * @memberof MicroCMS
   */
  async delete2<E extends K>(
    endpoint: E,
    id: string
  ): Promise<
    { code: 400; body: { message: string } } | { code: 202; body: { id: string } } | null
  > {
    const { service, apiWriteKey } = this.options;
    if (!apiWriteKey) return null;
    return fetch(`https://${service}.microcms.io/api/v1/${endpoint}/${id}`, {
      method: 'delete',
      headers: { 'X-WRITE-API-KEY': apiWriteKey, 'Content-Type': 'application/json' },
    })
      .then(async (res) => ({ code: res.status, body: true }))
      .catch(() => null) as ReturnType<typeof this.delete2>;
  }
}
